package com.prezi.gradle.pride

import com.prezi.gradle.pride.internal.LoggerOutputStream
import org.gradle.tooling.GradleConnector
import org.gradle.tooling.model.gradle.GradleBuild
import org.slf4j.Logger
import org.slf4j.LoggerFactory

/**
 * Created by lptr on 31/03/14.
 */
class PrideInitializer {
	private static final Logger log = LoggerFactory.getLogger(PrideInitializer)

	public static final String SETTINGS_GRADLE = "settings.gradle"
	public static final String BUILD_GRADLE = "build.gradle"

	private static final String DO_NOT_MODIFY_WARNING = """//
// DO NOT MODIFY -- This file is generated by Pride, and will be
// overwritten whenever the pride itself is changed.
//
"""

	private static ThreadLocal<GradleConnector> gradleConnector = new ThreadLocal<>() {
		@Override
		protected GradleConnector initialValue() {
			log.info "Starting Gradle connector"
			return GradleConnector.newConnector()
		}
	}

	public static void initializePride(File prideDirectory, boolean overwrite) {
		def prideExists = Pride.containsPride(prideDirectory)
		if (!overwrite && prideExists) {
			throw new PrideException("A pride already exists in ${prideDirectory}")
		}

		def settingsFile = new File(prideDirectory, SETTINGS_GRADLE)
		def buildFile = new File(prideDirectory, BUILD_GRADLE)
		def configDirectory = new File(prideDirectory, Pride.PRIDE_DIRECTORY)
		def prideModulesFile = new File(configDirectory, Pride.PRIDE_MODULES)
		def prideVersionFile = new File(configDirectory, Pride.PRIDE_VERSION)

		log.info (prideExists ? "Reinitializing" : "Initializing") + " ${prideDirectory}"
		prideDirectory.mkdirs()
		configDirectory.deleteDir()
		configDirectory.mkdirs()
		settingsFile.delete()
		buildFile.delete()

		prideVersionFile << "0\n"

		settingsFile << DO_NOT_MODIFY_WARNING

		prideDirectory.eachDir { moduleDirectory ->
			if (isValidProject(moduleDirectory)) {
				def connection = gradleConnector.get().forProjectDirectory(moduleDirectory).connect()
				try {
					def relativePath = prideDirectory.toURI().relativize(moduleDirectory.toURI()).toString()

					// Load the model for the build
					def builder = connection.model(GradleBuild)
					// Redirect output to loggers
					// Won't work until http://issues.gradle.org/browse/GRADLE-2687
					builder.standardError = new LoggerOutputStream({ log.error("{}", it) })
					builder.standardOutput = new LoggerOutputStream({ log.info("{}", it) })
					GradleBuild build = builder.get()

					// Merge settings
					settingsFile << "\n// Settings from project in directory /${relativePath}\n\n"
					build.projects.each { project ->
						if (project == build.rootProject) {
							settingsFile << "include '${build.rootProject.name}'\n"
							settingsFile << "project(':${build.rootProject.name}').projectDir = file('${moduleDirectory.name}')\n"
						} else {
							settingsFile << "include '${build.rootProject.name}${project.path}'\n"
						}
					}

					// Add module to .pride/modules
					prideModulesFile << "${moduleDirectory.name}\n"
				} finally {
					// Clean up
					connection.close()
				}
			}
		}

		// Add build.gradle
		buildFile << DO_NOT_MODIFY_WARNING << getClass().getResourceAsStream("/build.gradle")
	}

	private static boolean isValidProject(File dir) {
		log.debug "Scanning ${dir}"
		return !dir.name.startsWith(".") &&
				dir.list().contains(BUILD_GRADLE) ||
				dir.list().contains(SETTINGS_GRADLE)
	}
}
