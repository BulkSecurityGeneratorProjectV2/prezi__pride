package com.prezi.gradle.pride.cli

import com.prezi.gradle.pride.Module
import com.prezi.gradle.pride.Pride
import com.prezi.gradle.pride.PrideException
import com.prezi.gradle.pride.internal.LoggerOutputStream
import com.prezi.gradle.pride.vcs.VcsManager
import org.apache.commons.configuration.Configuration
import org.gradle.tooling.GradleConnector
import org.gradle.tooling.model.gradle.GradleBuild
import org.slf4j.Logger
import org.slf4j.LoggerFactory

/**
 * Created by lptr on 06/05/14.
 */
class PrideInitializer {
	private static final Logger logger = LoggerFactory.getLogger(PrideInitializer)

	private static final String DO_NOT_MODIFY_WARNING = """//
// DO NOT MODIFY -- This file is generated by Pride, and will be
// overwritten whenever the pride itself is changed.
//
"""

	private static final ThreadLocal<GradleConnector> gradleConnector = new ThreadLocal<>() {
		@Override
		protected GradleConnector initialValue() {
			logger.info "Starting Gradle connector"
			return GradleConnector.newConnector()
		}
	}

	public static Pride create(File prideDirectory, Configuration configuration, VcsManager vcsManager) {
		logger.info "Initializing ${prideDirectory}"
		prideDirectory.mkdirs()

		def configDirectory = Pride.getPrideConfigDirectory(prideDirectory)
		configDirectory.delete() || configDirectory.deleteDir()
		configDirectory.mkdirs()
		Pride.getPrideVersionFile(configDirectory) << "0\n"
		Pride.getPrideModulesFile(configDirectory).createNewFile()

		def pride = Pride.getPride(prideDirectory, configuration, vcsManager)
		reinitialize(pride)
		return pride
	}

	public static void reinitialize(Pride pride) {
		def buildFile = pride.gradleBuildFile
		buildFile.delete()
		buildFile << DO_NOT_MODIFY_WARNING << getClass().getResourceAsStream("/build.gradle")

		def settingsFile =pride. gradleSettingsFile
		settingsFile.delete()
		settingsFile << DO_NOT_MODIFY_WARNING

		pride.modules.each { Module module ->
			def moduleDirectory = new File(pride.rootDirectory, module.name)
			if (Pride.isValidModuleDirectory(moduleDirectory)) {
				initializeModule(pride, moduleDirectory, settingsFile)
			}
		}
	}

	private static void initializeModule(Pride pride, File moduleDirectory, File settingsFile) {
		def connection = gradleConnector.get().forProjectDirectory(moduleDirectory).connect()
		try {
			def relativePath = pride.rootDirectory.toURI().relativize(moduleDirectory.toURI()).toString()

			// Load the model for the build
			def builder = connection.model(GradleBuild)
			// Redirect output to loggers
			// Won't work until http://issues.gradle.org/browse/GRADLE-2687
			builder.standardError = new LoggerOutputStream({ logger.error("{}", it) })
			builder.standardOutput = new LoggerOutputStream({ logger.info("{}", it) })
			builder.withArguments("-q")
			GradleBuild build = builder.get()

			// Merge settings
			settingsFile << "\n// Settings from project in directory /${relativePath}\n\n"
			build.projects.each { project ->
				if (project == build.rootProject) {
					settingsFile << "include '${build.rootProject.name}'\n"
					settingsFile << "project(':${build.rootProject.name}').projectDir = file('${moduleDirectory.name}')\n"
				} else {
					settingsFile << "include '${build.rootProject.name}${project.path}'\n"
				}
			}
		} catch (Exception ex) {
			throw new PrideException("Could not parse module in ${moduleDirectory}: ${ex}", ex)
		} finally {
			// Clean up
			connection.close()
		}
	}
}
